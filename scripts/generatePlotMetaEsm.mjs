import fs from 'fs';
import path from 'path';
import prettier from 'prettier';
import glob from 'fast-glob';
import { fileURLToPath } from 'url';

// Constants
const PLOTS_ROOT = 'comparison_plots';
const OUTPUT_FILE = 'src/data/plotMeta.ts';

// Plot type mapping based on directory and filename patterns
const PLOT_TYPE_MAPPING = {
  '3d_visualization': '3D global-schedule',
  'best_strategies': 'Best strategies 2D',
  'skr_vs_fth': 'SKR vs F_th',
  'distance_ratio': 'Distance-ratio',
  'heatmap_dist': 'Advantage heatmaps',
  'grid_plateau': 'Plateau grid',
  'threshold': 'Threshold heatmap',
  'max_distance': 'η_c comparisons',
  'consolidated_threshold': 'Threshold heatmap',
  'manual_advantage': 'η_c comparisons'
};

// Dependency matrix from requirements
const DEPENDENCY_MATRIX = {
  '3D global-schedule': { eta_c: true, epsilon_G: true, N: true, M: true, rule: true },
  'Best strategies 2D': { eta_c: true, epsilon_G: true, N: true, M: true, rule: false },
  'SKR vs F_th': { eta_c: true, epsilon_G: true, N: true, M: true, rule: false },
  'Distance-ratio': { eta_c: false, epsilon_G: false, N: true, M: true, rule: false },
  'Advantage heatmaps': { eta_c: true, epsilon_G: true, N: false, M: false, rule: true },
  'Plateau grid': { eta_c: false, epsilon_G: false, N: false, M: false, rule: false },
  'Threshold heatmap': { eta_c: false, epsilon_G: false, N: false, M: true, rule: false },
  'η_c comparisons': { eta_c: false, epsilon_G: true, N: true, M: true, rule: true }
};

function parseEtaC(dirname) {
  const match = dirname.match(/^etac(\d+\.?\d*)$/);
  return match ? parseFloat(match[1]) : undefined;
}

function parseEpsilonG(dirname) {
  const match = dirname.match(/^epsg(\d+\.?\d*)$/);
  return match ? parseFloat(match[1]) : undefined;
}

function parseN(token) {
  const match = token.match(/^N(\d+)$/);
  return match ? parseInt(match[1], 10) : undefined;
}

function parseM(token) {
  const match = token.match(/^M(\d+)$/);
  return match ? parseInt(match[1], 10) : undefined;
}

function parseRule(token) {
  if (token === 'SKR') return token;
  const match = token.match(/^F_th_(\d+\.?\d*)$/);
  return match ? `F_th ${match[1]}` : undefined;
}

function getPlotType(filename) {
  for (const [key, value] of Object.entries(PLOT_TYPE_MAPPING)) {
    if (filename.includes(key)) {
      return value;
    }
  }
  return undefined;
}

async function generatePlotMeta() {
  try {
    // Find all plot files
    const plotFiles = await glob([
      `${PLOTS_ROOT}/**/*.{png,svg}`,
      `!${PLOTS_ROOT}/**/.*`,
      `!${PLOTS_ROOT}/**/_*`
    ]);

    // Initialize sets for unique parameter values
    const uniqueParams = {
      eta_c: new Set(),
      epsilon_G: new Set(),
      N: new Set(),
      M: new Set(),
      rule: new Set()
    };

    // Process each plot file
    const plotMeta = plotFiles.map(relPath => {
      const pathParts = relPath.split('/');
      const params = {};

      // Extract parameters from path
      pathParts.forEach(part => {
        const etaC = parseEtaC(part);
        const epsilonG = parseEpsilonG(part);
        const N = parseN(part);
        const M = parseM(part);
        const rule = parseRule(part);

        if (etaC !== undefined) {
          params.eta_c = etaC;
          uniqueParams.eta_c.add(etaC);
        }
        if (epsilonG !== undefined) {
          params.epsilon_G = epsilonG;
          uniqueParams.epsilon_G.add(epsilonG);
        }
        if (N !== undefined) {
          params.N = N;
          uniqueParams.N.add(N);
        }
        if (M !== undefined) {
          params.M = M;
          uniqueParams.M.add(M);
        }
        if (rule !== undefined) {
          params.rule = rule;
          uniqueParams.rule.add(rule);
        }
      });

      const plotType = getPlotType(relPath);
      if (!plotType) {
        console.warn(`Could not determine plot type for ${relPath}`);
      }

      return {
        plotType,
        params,
        relPath
      };
    });

    // Generate TypeScript code
    const code = `// Auto-generated by generatePlotMeta.ts
// DO NOT EDIT DIRECTLY

export interface PlotParams {
  eta_c?: number;
  epsilon_G?: number;
  N?: number;
  M?: number;
  rule?: string;
}

export interface PlotMeta {
  plotType: string;
  params: PlotParams;
  relPath: string;
}

export const plotMeta: PlotMeta[] = ${JSON.stringify(plotMeta, null, 2)};

export const plotTypes = Array.from(new Set(plotMeta.map(p => p.plotType))).sort();

export const parameterValues = {
  eta_c: ${JSON.stringify(Array.from(uniqueParams.eta_c).sort((a, b) => Number(a) - Number(b)))},
  epsilon_g: ${JSON.stringify(Array.from(uniqueParams.epsilon_G).sort((a, b) => Number(a) - Number(b)))},
  n: ${JSON.stringify(Array.from(uniqueParams.N).sort((a, b) => Number(a) - Number(b)))},
  m: ${JSON.stringify(Array.from(uniqueParams.M).sort((a, b) => Number(a) - Number(b)))},
  rule: ${JSON.stringify(Array.from(uniqueParams.rule).sort())}
};

export const dependencyMatrix = ${JSON.stringify(DEPENDENCY_MATRIX, null, 2)};
`;

    // Format with prettier
    const formattedCode = await prettier.format(code, { parser: 'typescript' });

    // Ensure output directory exists
    const outDir = path.dirname(OUTPUT_FILE);
    if (!fs.existsSync(outDir)) {
      fs.mkdirSync(outDir, { recursive: true });
    }

    // Write the file
    fs.writeFileSync(OUTPUT_FILE, formattedCode);
    console.log(`Successfully generated ${OUTPUT_FILE}`);

  } catch (err) {
    console.error('Error generating plot metadata:', err);
    process.exit(1);
  }
}

// Run the generator
generatePlotMeta(); 